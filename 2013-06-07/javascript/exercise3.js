	/*Exercise 3

	The model of a coniferous forest can be generated by building a very simplified tree model. The tree contains a cylinder and cone (with parametric height, radius and angular 
	discretization). The tree model must be instantiated several times using as a translation vector on the scene the three numbers generated by the coordinated functions of the digital 
	terrain model. Select one or more subsets of the ground to place the wooded areas on the slopes of the mountainous scene, adding a random term to increase the naturalness of the
	placement. NB. You can complicate the model of the tree at will to make it less "mechanical", for example correcting with random coefficients the height, radius and 
	angular discretization parameter of the crown.*/

	 var TerrainColor = [205/255,133/255,63/255];
	 var lakeColor = [0/255,0/255,128/255];
	 var pointOnMap = new Array();
	 var conifColor = [102/255,204/255,0];
	 var trunkColor = [153/255,76/255,0];
	 var treeArray = new Array(20);
	 var treeNumbers = 30;


	function getZ (v) {
		return Math.floor((Math.random()*10))*0.04; //normalizzato, altrimenti vengono picchi troppo alti e distanziati
	}

	function addPoint(v){
		this.pointOnMap.push(v);
	}

	var mapping = function (v) { 
		x = v[0];
		y = v[1];
		z = getZ();
		var point = {pxy:[x,y], pz:z, py:y, px:x }
		addPoint(point);
		return [x,y,z]
	};

	var dom = PROD1x1([INTERVALS(20)(50),INTERVALS(20)(50),INTERVALS(20)(50)])
	var terrain = COLOR(TerrainColor)(MAP(mapping)(dom));

	DRAW(terrain)


	//Esercizio 2
	function checkPairs(a,b){
		a0 = a[0];
		a1 = a[1];

		b0 = b[0];
		b1 = b[1];

		return (a0===b0 && a1===b1);
	}

	//Get coord z by the x and y
	function getZByXY(xy){
		var objpz;
		for(i=0; i<this.pointOnMap.length; i++)
			{
				obj = this.pointOnMap[i];
				if(checkPairs(obj.pxy, xy))
					{
					objpz = obj.pz ;
					}
			}
		return objpz
	}

	function translates(value, obj){
		obj = T([0,1,2])([value[0],value[1],value[2]])(obj)
		return obj;
	}


	function makeLake(){
		//l = COLOR(lakeColor)(CUBOID([4,2,0.01]));
		l =  COLOR(lakeColor)(DISK(2)(50));
		return l;
	}

	lake = makeLake();
	z = getZByXY([2,2]);
	lake = translates([8,4,z],lake);

	terrain = STRUCT([lake,terrain])


	//esercizio 3

	function circl (s) {
	  return function (r) {
	    return function (h) {
	      return function (p) {
	        return [ r * COS(s(p)), r * SIN(s(p)), h ];
	      };
	    };
	  };
	};


	function makeConiferous (r,h,slice ){
		var dom = DOMAIN([[0,2*PI],[0,1]])([50,1]);
		var trunk = CYL_SURFACE([r/5, h/3])(slice);
		var b = circl(S0)(r)(h/5);
		var cone = BEZIER(S1)([b, [0,0,h]]);
		cone = COLOR(conifColor)(MAP(cone)(dom));
		trunk = COLOR(trunkColor)(trunk)
		return STRUCT([trunk, cone]);
	}

	function makeForest(){
		var foresta;
		conf = makeConiferous(0.05,0.3,40);
		random = ~~Math.floor((Math.random()*2600)) //~~ troncate
		y = this.pointOnMap[random].py;
		x = this.pointOnMap[random].px;
		z = getZByXY([x,y])	
		tree = translates([x,y,z],conf);
		return tree;
	}


	for(j=0; j<treeNumbers;j++){
		terrain = STRUCT([makeForest(),terrain]);
	}

	DRAW(terrain)


