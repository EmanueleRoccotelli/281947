/*Exercise 4

Build near the edge of the mountainous area a model (in appropriate scale) of a human settlement, randomly assembling several parallel rectangular buildings 
(of varying heights and sizes). The settlement must be produced in local coordinates in function of some parameters, and then placed on the scene in at least two different 
instances, as produced by different generator parameters.
The student is free to select any number and meaning of the generator parameters.*/

/*Exercise 3

The model of a coniferous forest can be generated by building a very simplified tree model. The tree contains a cylinder and cone (with parametric height, radius and angular 
discretization). The tree model must be instantiated several times using as a translation vector on the scene the three numbers generated by the coordinated functions of the digital 
terrain model. Select one or more subsets of the ground to place the wooded areas on the slopes of the mountainous scene, adding a random term to increase the naturalness of the
placement. NB. You can complicate the model of the tree at will to make it less "mechanical", for example correcting with random coefficients the height, radius and 
angular discretization parameter of the crown.*/

 var TerrainColor = [205/255,133/255,63/255];
 var lakeColor = [0/255,0/255,128/255];
 var pointOnMap = new Array();
 var conifColor = [102/255,204/255,0];
 var trunkColor = [153/255,76/255,0];
 var treeArray = new Array(20);
 var treeNumbers = 30;

var colore_grigio = [1,1,1];
var colore_nero = [0,0,0]; 
var colore_rosso = [1,0,0];
var colore_verde = [0,1,0.5];
var colore_blu = [0,0,1];
var colore_verdone = [0.66,1.11,0.66];


function getZ () {
	return Math.floor((Math.random()*10))*0.04; //normalizzato, altrimenti vengono picchi troppo alti e distanziati
}

function addPoint(v){
	this.pointOnMap.push(v);
}

var mapping = function (v) { 
	x = v[0];
	y = v[1];
	z = getZ();
	var point = {pxy:[x,y], pz:z, py:y, px:x }
	addPoint(point);
	return [x,y,z]
};

var dom = PROD1x1([INTERVALS(20)(50),INTERVALS(20)(50),INTERVALS(20)(50)])
var terrain = COLOR(TerrainColor)(MAP(mapping)(dom));



//Esercizio 2
function checkPairs(a,b){
	a0 = a[0];
	a1 = a[1];

	b0 = b[0];
	b1 = b[1];

	return (a0===b0 && a1===b1);
}

//Get coor z by the x and y
function getZByXY(xy){
	var objpz;
	for(i=0; i<this.pointOnMap.length; i++)
		{
			obj = this.pointOnMap[i];
			if(checkPairs(obj.pxy, xy))
				{
				objpz = obj.pz ;
				}
		}
	return objpz
}

function translates(value, obj){
	obj = T([0,1,2])([value[0],value[1],value[2]])(obj)
	return obj;
}


function makeLake(){
	//l = COLOR(lakeColor)(CUBOID([4,2,0.01]));
	l =  COLOR(lakeColor)(DISK(2)(50));
	return l;
}

lake = makeLake();
z = getZByXY([2,2]);
lake = translates([8,4,z],lake);

terrain = STRUCT([lake,terrain])


//esercizio 3

function circl (s) {
  return function (r) {
    return function (h) {
      return function (p) {
        return [ r * COS(s(p)), r * SIN(s(p)), h ];
      };
    };
  };
};


function makeConiferous (r,h,slice ){
	var dom = DOMAIN([[0,2*PI],[0,1]])([50,1]);
	var trunk = CYL_SURFACE([r/5, h/3])(slice);
	var b = circl(S0)(r)(h/5);
	var cone = BEZIER(S1)([b, [0,0,h]]);
	cone = COLOR(conifColor)(MAP(cone)(dom));
	trunk = COLOR(trunkColor)(trunk)
	return STRUCT([trunk, cone]);
}

function makeForest(){
	var foresta;
	conf = makeConiferous(0.05,0.3,40);
	random = ~~Math.floor((Math.random()*2600))
	y = this.pointOnMap[random].py;
	x = this.pointOnMap[random].px;
	z = getZByXY([x,y])	
	tree = translates([x,y,z],conf);
	return tree;
}


for(j=0; j<treeNumbers;j++){
	terrain = STRUCT([makeForest(),terrain]);
}


//esercizio 4

function makeHouse(x,y,z){
	house = CUBOID([x,y,z]);
	return house;
}


house1 = COLOR(colore_rosso)(makeHouse(0.05,0.05,0.1));
house2 = COLOR(colore_rosso)(makeHouse(0.05,0.05,0.1));
house3 = COLOR(colore_rosso)(makeHouse(0.05,0.05,0.1));
house4 = COLOR(colore_rosso)(makeHouse(0.05,0.05,0.1));
house5 = COLOR(colore_rosso)(makeHouse(0.05,0.05,0.1));
house6 = COLOR(colore_rosso)(makeHouse(0.05,0.05,0.1));


z1 = this.getZByXY([2,2]);
console.log(z1)

z2 = this.getZByXY([4,2]);
console.log(z2)

z3 = this.getZByXY([3,3]);
console.log(z3)

z4 = this.getZByXY([5,1]);
console.log(z4)

z5 = this.getZByXY([3,3]);
console.log(z5)

z6 = this.getZByXY([6,1]);
console.log(z6)


house1 = translates([2,2,z1],house1);
house2 = translates([4,2,z2],house2);
house3 = translates([1,1,z3],house3);
house4 = translates([5,1,z4],house4);
house5 = translates([3,3,z5],house5);
house6 = translates([6,1,z6],house6);


terrain = STRUCT([terrain,house1,house2,house3,house4,house5,house6])

DRAW(terrain)

